---
title: The Scope Chain
date: 14-12-2025
excerpt: The physics of variable visibility: Lexical Scoping, the Outer Pointer, and the exact algorithm the engine uses to resolve variables.
---

### Lexical Scoping

JavaScript uses `Lexical Scoping` (also called Static Scoping) for variables and `Dynamic Scoping` for `this` keyword.

#### A. The Definition

Lexical refers to the `Physical Location` of the code in the source file.

- Rule: The scope of a variable is determined by where we Type the function, not where we Call the function.
- Timing: Because it is based on the text structure, the engine determines the scope hierarchy during the `Creation Phase`, long before the code actually runs.

#### B. Contrast with Dynamic Scoping

Some older languages use Dynamic Scoping (where scope depends on who called the function). JavaScript does not.

---

### The Physical Mechanism (Connecting Stack & Heap)

How does the engine actually see variables outside the current function? It relies on a two-step handshake between the Function Object (Heap) and the Execution Context (Stack).

#### A. The Handshake (Slot to Pointer)

1.  Step 1: Definition (The Snapshot)

    - When a function is declared, the engine saves the current Scope's memory address into the function's internal `[[Environment]]` slot (in the Heap).
    - Result: The function remembers where it was born.

2.  Step 2: Invocation (The Restore)

    - When the function is called, the engine creates a new Execution Context (Stack Frame).
    - It reads the function's `[[Environment]]` slot and copies that address into the new context's `outer` Pointer.
    - Result: The new Stack Frame is now physically linked to its parent scope.

#### B. The Hierarchy

This creates a linked list of environments.

- Local Scope (Bottom) to Parent Scope to Grandparent Scope to Global Scope (Top).

---

### Variable Resolution (The Lookup Algorithm)

When we try to access a variable (e.g., `console.log(username)`), the JavaScript Engine follows a strict 3 step algorithm to find the value.

#### Step 1: Local Lookup (Own Scope)

The engine checks the Current Variable Environment (Active Stack Frame).

- Question: Do I have a variable named `username` here?
- If Yes: Use it. Stop searching. (This is called `Shadowing`).
- If No: Proceed to Step 2.

#### Step 2: The Chain Traversal (The Walk)

The engine follows the `outer` pointer to the Parent Scope.

- Question: Do you have `username`?
- If Yes: Use it.
- If No: Follow the next `outer` pointer. Repeat until the Global Scope is reached.

#### Step 3: Global Check & Failure

The engine reaches the Global Scope (Window/Node Global).

- Question: Do you have `username`?
- If Yes: Use it.
- If No: Throw `ReferenceError: username is not defined`.

---

### Shadowing

Shadowing occurs when a variable in a local scope has the same name as a variable in an outer scope.

```javascript
let user = Global;

function login() {
  let user = Local; // Shadows the outer user
  console.log(user); // Output: Local
}
```

- Mechanism: The Resolution Algorithm finds `user` immediately in the Local Scope and stops. It never looks up the chain to see the Global version.

---

### üìù Summary Table

| Concept       | Definition                              | Determination Time     |
| :------------ | :-------------------------------------- | :--------------------- |
| Lexical Scope | Access based on Source Code Position    | Compile/Creation Phase |
| Scope Chain   | Linked List of Environments via `outer` | Runtime Traversal      |
| Shadowing     | Local var hiding outer var              | Runtime Execution      |
