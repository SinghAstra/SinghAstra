---
title: "Advanced Hooks & Performance"
date: "24-12-2025"
excerpt: "Moving beyond basic state. How to access the DOM directly, and how to optimize performance using Memoization."
---

# Advanced Hooks & Performance

## 1. useRef

So far, we've learned that if we want to change something on screen, you use `useState`.
But sometimes you need to step outside React's data flow.

### Use Case A: Accessing the DOM

React is declarative (we tell it what we want), but sometimes we need imperative control (focusing an input, scrolling to a div).

```javascript
function SearchBar() {
  const inputRef = useRef(null); // 1. Create the ref

  const handleFocus = () => {
    // 3. Access the DOM node directly
    inputRef.current.focus();
  };

  return (
    <>
      {/* 2. Attach ref to element */}
      <input ref={inputRef} type="text" />
      <button onClick={handleFocus}>Focus Input</button>
    </>
  );
}
```

### Use Case B: Mutable Variables (No Re-renders)

`useState` triggers a re-render when changed. `useRef` does not.
It's like a secret pocket where we can store data that persists between renders but doesn't affect the UI (e.g., storing a timer ID).

- Rule: If changing the value should update the screen, use `State`. If it shouldn't, use `Ref`.

---

## 2. Memoization

React is fast, but it can be wasteful. By default, if a Parent re-renders, all its Children re-render, even if their props didn't change.
Memoization is the technique of caching results so we don't do the same work twice.

### `useMemo`: Caching Values

Imagine a function that calculates `10,000 * 10,000`. We don't want to run that every time the user types a single letter in an unrelated input field.

```javascript
import { useMemo, useState } from "react";

function ExpensiveComponent({ data }) {
  // WITHOUT useMemo: Runs on every single render (slow!)
  // const sortedData = data.sort((a, b) => a - b);

  // WITH useMemo: Runs ONLY when 'data' changes
  const sortedData = useMemo(() => {
    console.log("Sorting data...");
    return data.sort((a, b) => a - b);
  }, [data]); // Dependency Array

  return <div>{/* Render sortedData */}</div>;
}
```

### `useCallback`: Caching Functions

In JavaScript, functions are objects. Every time a component renders, every function inside it is re-created brand new.

`function() {}` (Render 1) `!==` `function() {}` (Render 2)

This breaks optimization. If we pass a function to a Child, the Child thinks, "Oh, I got a new prop! I must re-render."

```javascript
import { useCallback } from "react";

function Parent() {
  const [count, setCount] = useState(0);

  // WITHOUT useCallback:
  // This function is "new" every render.
  // ChildComponent will re-render unnecessarily every time 'count' changes.
  // const handleClick = () => console.log("Clicked");

  // WITH useCallback:
  // React gives you the SAME function instance across renders
  // unless the dependency array changes.
  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []); // Stable function

  return <ChildComponent onClick={handleClick} />;
}
```

---

## 3. `React.memo` (The Guard)

`useCallback` is useless without `React.memo`.
`React.memo` is a Higher Order Component that wraps a child. It says: "Only re-render this component if its PROPS have changed."

```javascript
const ChildComponent = React.memo(function ({ onClick }) {
  console.log("Child Rendered");
  return <button onClick={onClick}>Click Me</button>;
});
```

The Combo:

1.  Parent uses `useCallback` to keep the function stable.
2.  Child uses `React.memo` to check if props are stable.
3.  Result: Child does not re-render when Parent updates unrelated state.

---

## üìù Summary Table

| Hook          | Returns                             | Purpose                                      | Re-renders Component?  |
| :------------ | :---------------------------------- | :------------------------------------------- | :--------------------- |
| `useRef`      | A mutable object `{ current: ... }` | Access DOM or store value without rendering. | No                     |
| `useMemo`     | A Value (Result of function)        | Cache expensive calculations.                | No (it's optimization) |
| `useCallback` | A Function definition               | Keep a function reference stable.            | No (it's optimization) |
| `React.memo`  | A Component                         | Prevent Child re-render if props match.      | N/A                    |

---

## üõë Stop and Think

1.  The Premature Optimization: Why shouldn't you just wrap _every_ function in `useCallback` and _every_ value in `useMemo`?
    - _(Hint: Does "checking if inputs changed" come for free? Memory overhead?)_
2.  The Ref Trap: If you display `{ref.current}` in your JSX (like `<div>{countRef.current}</div>`), will the number update on the screen when you change it?
    - _(Hint: Remember what triggers a render.)_
3.  The Dependency Logic: If you use `useCallback` but put `[count]` in the dependency array, and `count` changes every second, is the callback actually "stable"?
    - _(Hint: No. It regenerates every time dependencies change.)_

---
