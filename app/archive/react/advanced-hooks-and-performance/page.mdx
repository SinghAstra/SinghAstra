---
title: "Advanced Hooks & Performance"
date: "24-12-2025"
excerpt: "Moving beyond basic state. How to access the DOM directly, and how to optimize performance using Memoization."
---

# Advanced Hooks & Performance

## 1. useRef

While useState is for data that drives the UI, useRef is for data that needs to survive renders without triggering them.

Technically, useRef returns a mutable object that looks like this: `{ current: initialValue }`. Crucially, React guarantees that this exact same object instance is returned on every single render.

### Use Case A: Accessing the DOM

React is declarative (we tell it what we want), but sometimes we need imperative control (focusing an input, scrollIntoView for div for Chat Application).

```typescript
"use client";
import { Button } from "@/components/ui/button";
import { useRef } from "react";

function SearchBar() {
  // TS Generic: <HTMLInputElement> defines what kind of element this ref holds
  const inputRef = useRef<HTMLInputElement>(null);

  const handleFocus = () => {
    // Optional chaining (?) is needed because .current starts as null
    inputRef.current?.focus();
  };

  return (
    <div className="h-screen flex items-center justify-center">
      <div className="flex">
        <input
          className="border px-2 rounded"
          ref={inputRef}
          type="text"
          placeholder="Search..."
        />
        <Button
          variant={"outline"}
          className="bg-transparent hover:bg-muted/20"
          onClick={handleFocus}
        >
          Focus Input
        </Button>
      </div>
    </div>
  );
}

export default SearchBar;
```

```typescript
import { useRef } from "react";

function ChatBox() {
  // 1. Create a ref for the div we want to scroll to
  const bottomRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    // 3. Use the DOM API 'scrollIntoView'
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <div className="chat-container">
      <div className="messages">
        <p>Message 1</p>
        <p>Message 2</p>
        <p>Message 3</p>
        {/* ... potentially long list ... */}

        {/* 2. Attach ref to a dummy div at the end of the list */}
        <div ref={bottomRef} />
      </div>

      <button onClick={scrollToBottom}>Go to Bottom</button>
    </div>
  );
}
```

### Use Case B: Mutable Variables (No Re-renders)

`useState` triggers a re-render when changed. `useRef` does not.

> Rule: If changing the value should update the screen, use `State`. If it shouldn't, use `Ref`.

---

## 2. Memoization

React is fast, but it can be wasteful. By default, if a Parent re-renders, all its Children re-render, even if their props didn't change.
Memoization is the technique of caching results so we don't do the same work twice.

### `useMemo`: Caching Values

Imagine a function that calculates `10,000 * 10,000`. We don't want to run that every time the user types a single letter in an unrelated input field.

```javascript
import { useMemo, useState } from "react";

function ExpensiveComponent({ data }) {
  // WITHOUT useMemo: Runs on every single render (slow!)
  // const sortedData = data.sort((a, b) => a - b);

  // WITH useMemo: Runs ONLY when 'data' changes
  const sortedData = useMemo(() => {
    console.log("Sorting data...");
    return data.sort((a, b) => a - b);
  }, [data]); // Dependency Array

  return <div>{/* Render sortedData */}</div>;
}
```

### `useCallback`: Caching Functions

In JavaScript, functions are objects. Every time a component renders, every function inside it is re-created brand new.

`function() {}` (Render 1) `!==` `function() {}` (Render 2)

This breaks optimization. If we pass a function to a Child, the Child thinks, "Oh, I got a new prop! I must re-render."

```javascript
import { useCallback } from "react";

function Parent() {
  const [count, setCount] = useState(0);

  // WITHOUT useCallback:
  // This function is "new" every render.
  // ChildComponent will re-render unnecessarily every time 'count' changes.
  // const handleClick = () => console.log("Clicked");

  // WITH useCallback:
  // React gives you the SAME function instance across renders
  // unless the dependency array changes.
  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []); // Stable function

  return <ChildComponent onClick={handleClick} />;
}
```

---

## 3. `React.memo` (The Guard)

`useCallback` is useless without `React.memo`.
`React.memo` is a Higher Order Component that wraps a child. It says: "Only re-render this component if its PROPS have changed."

```javascript
const ChildComponent = React.memo(function ({ onClick }) {
  console.log("Child Rendered");
  return <button onClick={onClick}>Click Me</button>;
});
```

The Combo:

1.  Parent uses `useCallback` to keep the function stable.
2.  Child uses `React.memo` to check if props are stable.
3.  Result: Child does not re-render when Parent updates unrelated state.

---

## üìù Summary Table

| Hook          | Returns                             | Purpose                                      | Re-renders Component?  |
| :------------ | :---------------------------------- | :------------------------------------------- | :--------------------- |
| `useRef`      | A mutable object `{ current: ... }` | Access DOM or store value without rendering. | No                     |
| `useMemo`     | A Value (Result of function)        | Cache expensive calculations.                | No (it's optimization) |
| `useCallback` | A Function definition               | Keep a function reference stable.            | No (it's optimization) |
| `React.memo`  | A Component                         | Prevent Child re-render if props match.      | N/A                    |

---

## üõë Stop and Think

1.  The Premature Optimization: Why shouldn't you just wrap _every_ function in `useCallback` and _every_ value in `useMemo`?
    - _(Hint: Does "checking if inputs changed" come for free? Memory overhead?)_
2.  The Ref Trap: If you display `{ref.current}` in your JSX (like `<div>{countRef.current}</div>`), will the number update on the screen when you change it?
    - _(Hint: Remember what triggers a render.)_
3.  The Dependency Logic: If you use `useCallback` but put `[count]` in the dependency array, and `count` changes every second, is the callback actually "stable"?
    - _(Hint: No. It regenerates every time dependencies change.)_

---
