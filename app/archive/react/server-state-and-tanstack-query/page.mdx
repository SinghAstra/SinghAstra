---
title: "The Architecture of Server State"
date: "27-12-2025"
excerpt: "Why useEffect is an anti-pattern for data fetching. Understanding the fundamental split between Client and Server state."
---

# The Conflict: Client vs. Server State

To build professional React applications, we must stop treating data from an API as local state. The moment we fetch data and store it in `useState`, we have created a static snapshot of a moving target.

## 1. The Breakdown: Client vs. Server State

Modern React architecture dictates a hard separation between two types of memory:

### Client State

- Ownership: The Browser.
- Persistence: Temporary (cleared on refresh).
- Examples: `isModalOpen`, `currentTheme`, `formInputValues`.
- Tools: `useState`, `useReducer`, Zustand, Redux.

### Server State

- Ownership: The Remote Database.
- Persistence: Shared (others can change it while user view it).
- Status: Becomes Stale (outdated) the second it arrives in the browser.
- Tools: TanStack Query (React Query).

---

## 2. The useEffect Pitfall

Using `useState` + `useEffect` to manage server data is considered an imperative manual trap because it fails to handle the complexities of the network.

### A. Loading Spinner Hell

Every time a component remounts, `useEffect` triggers a new fetch. The user is forced to see a loading spinner for data they likely just saw seconds ago, damaging the perceived performance.

### B. The Single Source of Truth Problem

When we store API data in `useState`, we are duplicating the database locally. There is no built-in mechanism to ensure that our local version of a user profile stays in sync with the real version on the server.

---

## 3. Memory Management: The Waiting Room

A common misconception is that data is deleted as soon as it leaves the screen. TanStack Query uses a sophisticated memory lifecycle to ensure Back/Forward navigation is instant.

### Active vs. Inactive State

- Active: The data is currently being rendered on screen. TanStack Query tracks how many components are watching this data.
- Inactive: When we navigate away (e.g., from `User 1` to `User 2`), the data for `User 1` is not discarded. It is moved to the Inactive state the Waiting Room.

### The gcTime (Garbage Collection)

By default, TanStack Query keeps Inactive data in RAM for 5 minutes (`gcTime`).

- If we return to that page within 5 minutes, the UI is instant because the data is pulled from the Waiting Room.
- If we return after 5 minutes, the data is purged to save browser memory, and a fresh fetch occurs.

## 4. The TanStack Solution: Cache Mechanics

TanStack Query shifts the focus from Data Fetching to Cache Management.

### Request Deduplication

If five different components (Sidebar, Header, Profile, etc.) all require the same `['user']` data, TanStack Query intercepts the calls. It sends one network request and distributes the result to all observers, drastically reducing API overhead.

### The Stale-While-Revalidate (SWR) Pattern

This is the core engine of professional UX. It follows a three-step process:

1. Instant UI: Display the Stale (cached) data immediately so the user sees content without a spinner.
2. Background Revalidation: Silently fetch fresh data from the server in the background.
3. The Swap: Once the new data arrives, update the cache and re-render the UI seamlessly.

# The useQuery Blueprint

The `useQuery` hook is a declarative request to the Synchronization Engine. we don't tell React how to fetch; we describe what we need and where it should be stored in the cache.

## 1. The Anatomy of a Query

A standard query requires two primary ingredients: a Unique Key and a Fetcher Function.

```typescript
const { data, isLoading, error } = useQuery({
  // 1. The Cache Address (The Label)
  queryKey: ["user", userId],

  // 2. The Network Request (The Action)
  queryFn: () => fetch(`/api/users/${userId}`).then((res) => res.json()),

  // 3. Optional Configuration (The Rules)
  staleTime: 1000 * 60 * 5, // 5 minutes
});
```

### A. The Query Key

Query Keys must be Arrays.
TanStack Query uses these keys to:

- Deduplicate requests: If two components ask for `['user', 1]`, only one fetch happens.
- Identify Cache Entries: When we want to invalidate or update a user later, we find them by this key.

### B. The Query Function

The `queryFn` can be any function, as long as it returns a Promise. It should either resolve with data or throw an error. TanStack Query doesn't care if we use `fetch`, `axios`, or `GraphQL`.

---

## 2. Dynamic Keys

Just like the dependency array in `useEffect`, Query Keys are reactive.

If our key contains a variable (like `userId` or `pageNumber`), TanStack Query will automatically trigger a new fetch whenever that variable changes.

```typescript
// If 'page' changes from 1 to 2, a new fetch is triggered automatically.
// The data for Page 1 remains 'Inactive' in the cache.
const { data } = useQuery({
  queryKey: ["products", { category, page }],
  queryFn: () => fetchProducts(category, page),
});
```

---

## 3. Query Key Hierarchies

Think of Query Keys as a file-system. we can be specific or broad. This allows for Bulk Operations.

- `['posts']`: Everything in the posts folder.
- `['posts', 'list', { filter: 'new' }]`: A specific filtered list.
- `['posts', 123]`: A specific single post.

> Hierarchy Tip: Always put the most general string first and the most specific IDs or objects last. This makes it easier to say: Invalidate everything that starts with 'posts'.

---

## 4. Derived State from Queries

we don't need to put query data into a `useEffect` to transform it. Use the `select` option. This is a performance win because it memoizes the result.

```typescript
const { data: userCount } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
  // Transform the data before it reaches the component
  select: (users) => users.length,
});
```

# The Query Lifecycle

TanStack Query uses a `Stale-While-Revalidate` (SWR) logic that hinges on two core timestamps: `staleTime` and `gcTime`.

## 1. The Four States of Data

Every piece of data in our cache exists in one of four states at any given moment:

1.  Fresh: The data is considered accurate. If a component asks for it, React Query serves it from RAM and does not hit the network.
2.  Stale: The data is suspect. React Query will show it instantly to avoid a spinner, but it will trigger a background fetch to verify the data.
3.  Inactive: No components are currently using this data. It is moved to the Waiting Room.
4.  Deleted: The data is purged from memory to prevent leaks.

---

## 2. The Performance Knobs: staleTime vs. gcTime

These two settings are often confused, but they serve completely different purposes.

### A. staleTime (The Trust Window)

- Definition: How long data remains Fresh.
- Default: `0`
- Logic: By default, data is stale immediately. This is a Safety First approach React Query always checks the server to ensure the UI is accurate.
- Optimization: For data that rarely changes (e.g., a list of countries), set this to `1000 * 60 * 60` (1 hour) to eliminate redundant network calls.

### B. gcTime (The Garbage Collection Window)

- Definition: How long Inactive data stays in the cache before being deleted.
- Default: `5 minutes`
- Logic: This determines how long the Waiting Room lasts. If we navigate back to a page within 5 minutes, the UI is instant.

---

## 3. Smart Refetch Triggers

React Query does not fetch in a loop. It is event driven. It waits for Smart Triggers to re-verify stale data:

1.  Refetch on Mount: A component using the query appears on screen.
2.  Refetch on Window Focus: User leave the tab (to check email) and come back. This is how the app stays in sync without a "Refresh" button.
3.  Refetch on Reconnect: The user's internet was lost and is now restored.
4.  Refetch Interval (Polling): A manual timer (e.g., fetch every 10s) for live dashboards.

---

## 4. The Trust, but Verify Flow

When we navigate back to a user profile you've seen before, this sequence occurs:

1.  Trust: React Query finds the data in the cache (even if it's Inactive). It displays it instantly.
2.  Identify: It sees the data is Stale (because `staleTime` is 0).
3.  Verify: It triggers a Background Refetch.
4.  Sync: If the data has changed (e.g., the user updated their bio), the UI silently updates. If not, nothing changes.

---

## ðŸ“ Summary Table

| Feature       | Manual (useEffect + useState) | TanStack Query                          |
| :------------ | :---------------------------- | :-------------------------------------- |
| Philosophy    | Imperative (How to get data)  | Declarative (What data is needed)       |
| Caching       | Manual / Difficult            | Automatic & Persistent                  |
| Deduplication | No (Fetch runs per component) | Yes (Smart request sharing)             |
| Performance   | Blocked by spinners           | Instant via SWR Pattern                 |
| Syncing       | Manual triggers               | Auto-refetch on window focus/tab switch |

| Property   | Purpose        | Logic                                                           |
| ---------- | -------------- | --------------------------------------------------------------- |
| `queryKey` | Identity       | Unique array used for caching and dependency tracking.          |
| `queryFn`  | Action         | A function returning a Promise that resolves the data.          |
| `enabled`  | Control        | Set to `false` to prevent the query from running automatically. |
| `select`   | Transformation | Filters or transforms the data returned by the fetcher.         |

| Property               | Default  | Role                                         |
| :--------------------- | :------- | :------------------------------------------- |
| `staleTime`            | `0`      | How long until data needs "Verification."    |
| `gcTime`               | `5 mins` | How long until data is "Forgotten" entirely. |
| `refetchOnWindowFocus` | `true`   | Re-verify when the user returns to the tab.  |
| `refetchOnMount`       | `true`   | Re-verify when a component appears.          |

---

## ðŸ›‘ Stop and Think

> React Query is not a data-fetching library; it is a Synchronization Engine. It ensures that the browser's memory is an accurate, up-to-date mirror of the server's reality.

> Query Keys are the 'folders' of our application's memory. If we change a key, we aren't just changing a variable; we are opening a new folder. If that folder is empty, we'll see a spinner. If it has 'Inactive' data from 2 minutes ago, the UI will be instant.

> If we set `staleTime` to infinity and `gcTime` to infinity, we have essentially built a 'Static App.' The data will load once and never update again unless the user refreshes the browser. Mastering these two variables is how we balance UI speed with Data Accuracy.

---
