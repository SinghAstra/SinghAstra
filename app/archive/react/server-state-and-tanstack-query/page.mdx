---
title: "The Architecture of Server State"
date: "27-12-2025"
excerpt: "Why useEffect is an anti-pattern for data fetching. Understanding the fundamental split between Client and Server state."
---

# The Conflict: Client vs. Server State

To build professional React applications, we must stop treating data from an API as local state. The moment we fetch data and store it in `useState`, we have created a static snapshot of a moving target.

## 1. The Breakdown: Client vs. Server State

Modern React architecture dictates a hard separation between two types of memory:

### Client State

- Ownership: The Browser.
- Persistence: Temporary (cleared on refresh).
- Examples: `isModalOpen`, `currentTheme`, `formInputValues`.
- Tools: `useState`, `useReducer`, Zustand, Redux.

### Server State

- Ownership: The Remote Database.
- Persistence: Shared (others can change it while user view it).
- Status: Becomes Stale (outdated) the second it arrives in the browser.
- Tools: TanStack Query (React Query).

---

## 2. The useEffect Pitfall

Using `useState` + `useEffect` to manage server data is considered an imperative manual trap because it fails to handle the complexities of the network.

### A. Loading Spinner Hell

Every time a component remounts, `useEffect` triggers a new fetch. The user is forced to see a loading spinner for data they likely just saw seconds ago, damaging the perceived performance.

### B. The Single Source of Truth Problem

When we store API data in `useState`, we are duplicating the database locally. There is no built-in mechanism to ensure that our local version of a user profile stays in sync with the real version on the server.

---

## 3. Memory Management: The Waiting Room

A common misconception is that data is deleted as soon as it leaves the screen. TanStack Query uses a sophisticated memory lifecycle to ensure Back/Forward navigation is instant.

### Active vs. Inactive State

- Active: The data is currently being rendered on screen. TanStack Query tracks how many components are watching this data.
- Inactive: When we navigate away (e.g., from `User 1` to `User 2`), the data for `User 1` is not discarded. It is moved to the Inactive state the Waiting Room.

### The gcTime (Garbage Collection)

By default, TanStack Query keeps Inactive data in RAM for 5 minutes (`gcTime`).

- If we return to that page within 5 minutes, the UI is instant because the data is pulled from the Waiting Room.
- If we return after 5 minutes, the data is purged to save browser memory, and a fresh fetch occurs.

## 4. The TanStack Solution: Cache Mechanics

TanStack Query shifts the focus from Data Fetching to Cache Management.

### Request Deduplication

If five different components (Sidebar, Header, Profile, etc.) all require the same `['user']` data, TanStack Query intercepts the calls. It sends one network request and distributes the result to all observers, drastically reducing API overhead.

### The Stale-While-Revalidate (SWR) Pattern

This is the core engine of professional UX. It follows a three-step process:

1. Instant UI: Display the Stale (cached) data immediately so the user sees content without a spinner.
2. Background Revalidation: Silently fetch fresh data from the server in the background.
3. The Swap: Once the new data arrives, update the cache and re-render the UI seamlessly.

---

## ðŸ“ Summary Table

| Feature       | Manual (useEffect + useState) | TanStack Query                          |
| :------------ | :---------------------------- | :-------------------------------------- |
| Philosophy    | Imperative (How to get data)  | Declarative (What data is needed)       |
| Caching       | Manual / Difficult            | Automatic & Persistent                  |
| Deduplication | No (Fetch runs per component) | Yes (Smart request sharing)             |
| Performance   | Blocked by spinners           | Instant via SWR Pattern                 |
| Syncing       | Manual triggers               | Auto-refetch on window focus/tab switch |

---

## ðŸ›‘ Stop and Think

> "React Query is not a data-fetching library; it is a Synchronization Engine. It ensures that the browser's memory is an accurate, up-to-date mirror of the server's reality."
